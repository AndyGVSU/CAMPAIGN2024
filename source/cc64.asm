;cc64.asm
;C64-MODIFIED FUNCTIONS

_GX_INIT 
	LDA #C_BLACK
	STA BACKCOL
	LDA #C_DRED
	STA BACKCOL+1
	LDA #C_WHITE
	STA BACKCOL+2
	RTS 

_GX_FILL 
	LDA OFFSET
	STA GX_X
	LDA OFFSET+1
	STA GX_Y

	LDX #00
@STORPTR 
	LDA SPRPTR,X
	STA V_SPRPTR,X
	INX 
	CPX #$08
	BNE @STORPTR

	LDA #$00
	STA OFFSET
	LDA #$04
	STA OFFSET+1
	LDY #00
@LOOP 
	LDA #$20
	STA (OFFSET),Y
	LDA OFFSET+1
	CLC 
	ADC #$D4
	STA OFFSET+1
	LDA GX_PCOL
	STA (OFFSET),Y
	LDA OFFSET+1
	SEC 
	SBC #$D4
	STA OFFSET+1
	INY 
	BNE @LOOP
	INC OFFSET+1
	LDA OFFSET+1
	CMP #$08
	BNE @LOOP

	LDX #00
@STORPT2 
	LDA V_SPRPTR,X
	STA SPRPTR,X
	INX 
	CPX #$08
	BNE @STORPT2

	RTS 

_RNGINIT 
	LDA #$00
	STA $D400
	STA $D401
	LDA #$FF
	STA $D40F
	LDA #$80
	STA $D412
	RTS

_GETINP 
@LOOP
	LDA #JOYDEF2
	STA V_JOY2
	LDA #JOYDEF1
	STA V_JOY1
	
	LDX #00
	TAX
@CLR
	STA V_KEYBUF,X
	INX
	CPX #10
	BNE @CLR
	
	JSR _SCNKEY
	JSR _GETIN
	CMP #$00
	BEQ @LOOP

	RTS 

;just changes the map's character colors
_DRWMAP 
	JSR _MAPCHAR
	+__LAB2O D_MAPSHP
	+__LAB2O2 COLRAM_MAP

	LDA #00
	STA GX_CROW
@ROWLOOP 
	LDA #00
	STA GX_CCOL
@COLLOOP 
	LDY #00
	LDA (OFFSET),Y
	BEQ @CLEAR
	TAX 
	LDA V_STCOL,X
	JMP @COLOR
@CLEAR 
	LDA #C_BLACK
@COLOR 
	STA (OFFSET2),Y

	JSR _DRWMAP2
	INC GX_CCOL
	LDA GX_CCOL

	CMP #MAP_COLC
	BNE @COLLOOP

	LDA OFFSET2
	CLC 
	ADC #MAP_ROWC
	STA OFFSET2
	BCC @CARRY
	INC OFFSET2+1
@CARRY 

	INC GX_CROW
	LDA GX_CROW
	CMP #MAP_ROWC
	BNE @ROWLOOP
@SKIP 
	RTS 
;increments offsets
_DRWMAP2 
	LDA OFFSET
	CLC 
	ADC #$01
	STA OFFSET
	BCC @CARRY
	INC OFFSET+1
@CARRY 
	LDA OFFSET2
	CLC 
	ADC #$01
	STA OFFSET2
	BCC @CARRY2
	INC OFFSET2+1
@CARRY2 
	RTS 

;draws a block of filled characters
_MAPCHAR
	
	+__LAB2O2 D_MAPCHR 
	+__LAB2O (V_SCREEN+44)
	
	LDX #$00 ;row
	STX FVAR2
	
@ROWLOOP
	LDY #00
@COLLOOP
	LDA (OFFSET2),Y
	STA (OFFSET),Y
	INY
	CPY #MAP_COLC
	BNE @COLLOOP
	INC FVAR2
	LDA FVAR2
	CMP #MAP_ROWC
	BEQ @DONE
	LDX #01
	LDY #40
	JSR _OFFSET
	LDA OFFSET2
	CLC
	ADC #MAP_COLC
	STA OFFSET2
	BCC @CARRY
	INC OFFSET2+1
@CARRY
	JMP @ROWLOOP
@DONE
	RTS 

;sprites initialize
_SPRINIT 
	LDA #00
	TAX 
	TAY 
@SPRCOPY 
	LDA D_SPRITE,Y
	STA V_SPRITE,Y
	INY 
	CPY #$80
	BNE @SPRCOPY

	LDA #$21
	STA SPRPTR+0
	LDA #$22
	STA SPRPTR+1
	LDX #$07
	LDA #$0C
@COLRES 
	STA SPRCOL,X
	DEX 
	BPL @COLRES
	LDA #$01
	STA SPRDBL
	LDA #$01
	STA SPRPOS8
	LDA #$04
	STA SPRPOS+0
	LDA #$32
	STA SPRPOS+1
	LDA #$36
	STA SPRPOS+2
	LDA #$38
	STA SPRPOS+3
	RTS
	
;yes_or_no()
;displays a yes or no prompt
_YESORNO
	+__COORD P_NOYESR,P_NOYESC
	+__LAB2XY T_NOYES
_YESORNO2
	JSR _GX_STR	
	LDX #P_NOYESR
	LDY #P_NOYESR+1
	JSR _RSELECT
	RTS

;load_neglect(X = state index if not from history)
_LDANEGL
	LDA V_SUMFH
	BNE @HIST
	LDA V_NEGLECT,X
	RTS
@HIST
	LDY #06
	LDA (HS_ADDR),Y
	RTS

;float_add_with_flag_set()
;FADDT work correctly
_FADDFLAG
	LDA #00
	STA ARG+6 ;why does this work???
	LDA FAC
	JSR _FADDT
	RTS
	
;table_jsr(X/Y = jump table address, A = jump table index) 
_TABLJSR
	;modify load address
	STX @L1+1
	STY @L1+2
	STX @L2+1
	STY @L2+2
	
	;set load address
	ASL
	TAX
@L1
	LDA $0000,X
	PHA
	INX
@L2
	LDA $0000,X
	STA @TEST+2
	PLA
	STA @TEST+1
@TEST	
	;execute
	JSR $0000
	RTS
	
;3P_balance_lean()
;giving 3P max SL of D/R is too powerful; it makes TV ADS too lucrative
;so, a randomly selected half of 3P's non-megastates are nerfed by 1
_3PBALANCE
	LDY #00
	LDX #00
@MEGALP
	LDA D_MEGAST,X
	STA V_PRIORI,X
	INX
	CPX #MEGASTAC
	BNE @MEGALP
	
	LDY #00 ;state list index
@GENLOOP
	JSR _RANDSTATE
	
	LDX #00 ;state list index 2
@CHECKDUP
	LDA V_PRIORI,X
	BEQ @EMPTY
	CMP FSTATE
	BEQ @GENLOOP
	INX
	CPY #STATE_C/2
	BNE @CHECKDUP
	BEQ @DONE
@EMPTY	
	LDA FSTATE
	STA V_PRIORI,X
	JSR _CPOFFS
	STY FY1
	LDY #CPBLEAN+2
	LDA (CP_ADDR),Y
	SEC
	SBC #01
	STA (CP_ADDR),Y
	LDY FY1
	INY
	JMP @GENLOOP
@DONE
	RTS