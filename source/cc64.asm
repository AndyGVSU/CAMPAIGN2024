;cc64.asm
;C64-MODIFIED FUNCTIONS

_GX_INIT 
	LDA #C_BLACK
	STA BACKCOL
	LDA #C_DRED
	STA BACKCOL+1
	LDA #C_WHITE
	STA BACKCOL+2
	RTS 

_GX_FILL 
	LDA OFFSET
	STA GX_X
	LDA OFFSET+1
	STA GX_Y

	LDX #00
@STORPTR 
	LDA SPRPTR,X
	STA V_SPRPTR,X
	INX 
	CPX #$08
	BNE @STORPTR

	LDA #$00
	STA OFFSET
	LDA #$04
	STA OFFSET+1
	LDY #00
@LOOP 
	LDA #$20
	STA (OFFSET),Y
	LDA OFFSET+1
	CLC 
	ADC #$D4
	STA OFFSET+1
	LDA GX_PCOL
	STA (OFFSET),Y
	LDA OFFSET+1
	SEC 
	SBC #$D4
	STA OFFSET+1
	INY 
	BNE @LOOP
	INC OFFSET+1
	LDA OFFSET+1
	CMP #$08
	BNE @LOOP

	LDX #00
@STORPT2 
	LDA V_SPRPTR,X
	STA SPRPTR,X
	INX 
	CPX #$08
	BNE @STORPT2

	RTS 

_RNGINIT 
	LDA #$00
	STA $D400
	STA $D401
	LDA #$FF
	STA $D40F
	LDA #$80
	STA $D412
	RTS

_GETINP 
@LOOP
	LDA #JOYDEF2
	STA V_JOY2
	LDA #JOYDEF1
	STA V_JOY1
	
	LDX #00
	TAX
@CLR
	STA V_KEYBUF,X
	INX
	CPX #10
	BNE @CLR
	
	JSR _SCNKEY
	JSR _GETIN
	CMP #$00
	BEQ @LOOP

	RTS 

;just changes the map's character colors
_DRWMAP 
	JSR _MAPCHAR
	+__LAB2O D_MAPSHP
	+__LAB2O2 COLRAM_MAP

	LDA #00
	STA GX_CROW
@ROWLOOP 
	LDA #00
	STA GX_CCOL
@COLLOOP 
	LDY #00
	LDA (OFFSET),Y
	BEQ @CLEAR
	TAX 
	LDA V_STCOL,X
	JMP @COLOR
@CLEAR 
	LDA #C_BLACK
@COLOR 
	STA (OFFSET2),Y

	JSR _DRWMAP2
	INC GX_CCOL
	LDA GX_CCOL

	CMP #MAP_COLC
	BNE @COLLOOP

	LDA OFFSET2
	CLC 
	ADC #MAP_ROWC
	STA OFFSET2
	BCC @CARRY
	INC OFFSET2+1
@CARRY 

	INC GX_CROW
	LDA GX_CROW
	CMP #MAP_ROWC
	BNE @ROWLOOP
@SKIP 
	RTS 
;increments offsets
_DRWMAP2 
	LDA OFFSET
	CLC 
	ADC #$01
	STA OFFSET
	BCC @CARRY
	INC OFFSET+1
@CARRY 
	LDA OFFSET2
	CLC 
	ADC #$01
	STA OFFSET2
	BCC @CARRY2
	INC OFFSET2+1
@CARRY2 
	RTS 

;draws a block of filled characters
_MAPCHAR
	
	+__LAB2O2 D_MAPCHR 
	+__LAB2O (V_SCREEN+44)
	
	LDX #$00 ;row
	STX FVAR2
	
@ROWLOOP
	LDY #00
@COLLOOP
	LDA (OFFSET2),Y
	STA (OFFSET),Y
	INY
	CPY #MAP_COLC
	BNE @COLLOOP
	INC FVAR2
	LDA FVAR2
	CMP #MAP_ROWC
	BEQ @DONE
	LDX #01
	LDY #40
	JSR _OFFSET
	LDA OFFSET2
	CLC
	ADC #MAP_COLC
	STA OFFSET2
	BCC @CARRY
	INC OFFSET2+1
@CARRY
	JMP @ROWLOOP
@DONE
	RTS 

;sprites initialize
_SPRINIT 
	LDA #00
	TAX 
	TAY 
@SPRCOPY 
	LDA D_SPRITE,Y
	STA V_SPRITE,Y
	INY 
	CPY #$80
	BNE @SPRCOPY

	LDA #$21
	STA SPRPTR+0
	LDA #$22
	STA SPRPTR+1
	LDX #$07
	LDA #$0C
@COLRES 
	STA SPRCOL,X
	DEX 
	BPL @COLRES
	LDA #$01
	STA SPRDBL
	LDA #$01
	STA SPRPOS8
	LDA #$04
	STA SPRPOS+0
	LDA #$32
	STA SPRPOS+1
	LDA #$36
	STA SPRPOS+2
	LDA #$38
	STA SPRPOS+3
	LDA #00
	LDY #$04
	RTS

;draw_blank(A = count)
_DRWBLANK
    STA T_BLANKX+4
    +__LAB2XY T_BLANKX
    JSR _GX_STR
	RTS
	
;yes_or_no()
;displays a yes or no prompt
_YESORNO
	+__COORD P_NOYESR,P_NOYESC
	+__LAB2XY T_NOYES
_YESORNO2
	JSR _GX_STR	
	LDX #P_NOYESR
	LDY #P_NOYESR+1
	JSR _RSELECT
	RTS

;load_neglect(X = state index if not from history)
_LDANEGL
	LDA V_SUMFH
	BNE @HIST
	LDA V_NEGLECT,X
	RTS
@HIST
	LDY #06
	LDA (HS_ADDR),Y
	RTS

;float_add_with_flag_set()
;FADDT work correctly
_FADDFLAG
	LDA #00
	STA ARG+6 ;why does this work???
	LDA FAC
	JSR _FADDT
	RTS
	
;table_jsr(X/Y = jump table address, A = jump table index) 
_TABLJSR
	;modify load address
	STX @L1+1
	STY @L1+2
	STX @L2+1
	STY @L2+2
	
	;set load address
	ASL
	TAX
@L1
	LDA $0000,X
	PHA
	INX
@L2
	LDA $0000,X
	STA @TEST+2
	PLA
	STA @TEST+1
@TEST	
	;execute
	JSR $0000
	RTS
	
;copies V_MAX1B to V_MAX
_MAX1B
	LDX #00
	LDY #00
@LOOP
	LDA V_MAX1B,X
	STA V_MAX+1,Y
	INX
	INY
	INY
	CPX #$04
	BNE @LOOP
	RTS
	
;unpack_nibble(V_NIBBLE+0)
;unpacks two 4-bit values
;returns to V_NIBBLE+0, V_NIBBLE+1
_UNIBBLE
	LDA V_NIBBLE
	PHA
	AND #%11110000
	LSR
	LSR
	LSR
	LSR
	STA V_NIBBLE+0
	PLA
	AND #%00001111
	STA V_NIBBLE+1
	RTS
	
;reset_visit_bonus()
_RESETVB
	LDA C_VBONUS
	STA V_VBONUS
	RTS