;ccalc.asm
;CAMP02 
;game math

;cp_+5_store() 
;stores to current cp addr and +5
_CP5STOR STA (CP_ADDR),Y
	INY 
	INY 
	INY 
	INY 
	INY 
	STA (CP_ADDR),Y
	RTS 

;detailed_results(FSTATE = state)
;draws history results for a state
;LOCAL: FVAR1
_DETAIL 
	JSR _MAXR
	LDA #$01
	STA V_SUMFH
	LDA #>V_HIST
	STA HS_ADDR+1
	LDA FSTATE
	STA FARG1
	JSR _CPOFFS
	JSR _GX_CLRS
	;draw header
	DEC HS_ADDR+1

	LDA #P_LEFT
	STA GX_CCOL
	LDA #P_DETSTR
	STA GX_CROW
	LDA #C_LBLUE
	STA GX_DCOL
	LDA FSTATE
	JSR _DRWPOST
	INC GX_CCOL
	INC GX_CCOL
	+__LAB2XY T_HIST
	JSR _GX_STR

	LDA #00
	STA V_WEEK
	LDA #P_DETLR
	STA GX_CROW
@WEEKLOOP 
	INC HS_ADDR+1
	;draw row
	LDA #P_LEFT
	STA GX_CCOL
	;draw row
	LDA #01
	STA S_SUMUND
	JSR _POPSUMR
	JSR _STATSUM

	LDA V_WEEK
	CMP #$0A
	BEQ @FINALW
	CMP #$0B
	BEQ @TOTAL
	
	ORA #$30
	BNE @NOTFIN
@FINALW 
	LDA #$4C ;L
	BNE @NOTFIN
@TOTAL
	INC GX_CROW
	JMP @FIN
@NOTFIN 
	STA GX_CIND
	LDA #C_WHITE
	STA GX_DCOL
	JSR _GX_CHAR
@FIN
	LDY #00
	STY FVAR1

	INC GX_CCOL
@PTLOOP 
	INC GX_CCOL

	LDY FVAR1
	LDA V_PTCOL,Y
	STA GX_DCOL
	TYA 
	ASL 
	TAY 
	JSR _PERCSTA
	+__LAB2XY V_FPOINT
	JSR _GX_STR
	INC FVAR1
	LDY FVAR1
	CPY #05
	BEQ @WEEKDONE
	CPY S_PLAYER
	BNE @PTLOOP
	LDY #UND_PRTY
	STY FVAR1
	BNE @PTLOOP
@WEEKDONE 
	INC GX_CCOL
	;recalc total without UND
	LDA #00
	STA S_SUMUND
	JSR _POPSUMR
	JSR _STATSUM
	JSR _SFVAR
	JSR _MARGIN
	BEQ @TIE
	DEC FVAR4
	LDA FVAR4 ;get control party
	STA FX1
	JSR _LFVAR

	LDX FX1
	JSR _DRWPN1
	LDA #$2B ;+
	STA GX_CIND
	JSR _GX_CHAR

	INC GX_CCOL
	+__LAB2XY V_FPOINT
	JSR _GX_STR
	JMP @SKIPTIE
@TIE 
	JSR _LFVAR
	+__LAB2XY T_TIE
	JSR _GX_STR
@SKIPTIE 
	JSR _GXINCRW
	INC V_WEEK
	LDA V_WEEK
	CMP #$0C
	BEQ @SKIPLOOP
	JMP @WEEKLOOP
@SKIPLOOP 
	RTS 

;mask() 
;blanks map
_FILMASK 
	LDA #01
	TAX 
@LOOP 
	STA V_COLMSK,X
	INX 
	CPX #STATE_C
	BNE @LOOP
	RTS 

;sum_ec(FARG5 = state limit (usually STATE_C))
;sums EC by party control
_SUMEC 
	LDA #00
	TAX 
@CLR 
	STA V_SUMEC,X
	INX 
	CPX #$0A
	BNE @CLR
	TAX 

	LDY #01
	STY FSTATE
@LOOP 
	LDY FSTATE
	LDA V_CTRL,Y
	ASL 
	TAX 
	LDA V_SUMEC,X
	LDY FSTATE
	CLC 
	ADC V_EC,Y
	STA V_SUMEC,X
	BCC @CARRY
	INC V_SUMEC+1,X
@CARRY 


	INC FSTATE
	LDA FSTATE
	CMP FARG5
	BNE @LOOP

	RTS 

;state_get_region(A=state index)
;returns region to X
_STATEGR 
	LDX #00
@LOOP 
	INX
	CMP D_REGLIM,X
	BCS @LOOP
	RTS 

;national_campaign(FARG1=extra region,FARG2=base value)
;for pregame / lastminute -- all states
;directly adds base value CP + issue bonus at no cost
;DOES add CP / 4 to opponents
;LOCAL: FVAR3,FARG3
_NATCAMP 
	LDA FARG1
	STA FARG3

	LDA #STATE_C
	STA FVAR3
	LDA #01
	STA FSTATE
	STA FARG1
@OFFSET 
	JSR _CPOFFS
@LOOP 
	LDA FSTATE
	STA FARG1

	LDA #00
	STA FRET1
	JSR _CISSUEB
	LDA FRET1
	ASL 
	CLC 
	ADC FARG2
	LSR ;(issue ; 2 + base) / 2 
	STA FRET1

	JSR _ADDCPU
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP FVAR3
	BNE @LOOP

	LDX FARG3
	BEQ @RTS
	LDA D_REGLIM,X
	STA FVAR3
	LDA D_REGLIM-1,X


	STA FSTATE
	STA FARG1
	LDA #00
	STA FARG3
	BEQ @OFFSET
@RTS 
	RTS 

;pregame_campaign() 
;national campaign for beginning of game
_PRECAMP 
	LDA C_CER
	STA FARG2
	LDA C_CREG
	STA FARG1
	JSR _NATCAMP
	JSR _CANDSWAP
	LDA V_PARTY
	BNE _PRECAMP

	JSR _MAPCOL
	RTS 

;postgame_campaign() 
;national campaign for end of game
_PSTCAMP 
	LDA C_LMIN
	ASL
	CLC 
	ADC C_CER ;base = CER + LMIN * 2
	STA FARG2
	LDA C_CREG
	STA FARG1
	JSR _NATCAMP
	JSR _CANDSWAP
	LDA V_PARTY
	BNE _PSTCAMP

	JSR _MAPCOL
	RTS 

;add_cp_from_undecided(FRET1 = CP GAIN)
;takes CP from UND and adds to current; if UND out, /4
;CP_ADDR = current state
;LOCAL: FVAR6
_ADDCPU
	LDA #$00
	STA FVAR6 ;do _ADDCPU2

	LDY V_LSTATE
	LDA #00
	STA V_REVERT,Y
	JMP _ADDCPUN2
;add_cp_from_undecided_no_revert
;call for REVERT LEAN
_ADDCPUN
	LDA #$01
	STA FVAR6
_ADDCPUN2
	LDA S_PLAYER
	CMP #$04
	BNE @HALVE
	LSR FRET1 ;1/2 CP IN 4 PLAYER GAME
@HALVE
	LDY V_LSTATE ;current cp_addr state
	LDA V_UNDCP,Y
	CMP FRET1
	BCC @LESSUND
	;if more or equal UND CP than CP gain:
	LDY #UND_OFFS
	LDA (CP_ADDR),Y
	SEC 
	SBC FRET1
	STA (CP_ADDR),Y
	BCS @OVERFLW
	LDA #$00 ;can occur due to V_UNDCP use
	STA (CP_ADDR),Y
@OVERFLW 
	LDY V_PARTY
	INY 
	LDA (CP_ADDR),Y
	CLV 
	CLC 
	ADC FRET1
	JSR _ADDCPU1
	LDA FRET1
	TAX 
	JSR _ADDCPU2
	RTS 
	;if less UND than CP gain:
@LESSUND 
	TAX 
	LDY V_PARTY
	INY 
	CLV 
	CLC 
	ADC (CP_ADDR),Y
	BCC @OVER2
	LDA #$FF
@OVER2	
	STA (CP_ADDR),Y ;add all of UND to the gaining party
	JSR _ADDCPU2 ;add 1/4 of the same amount to all other parties
	
	LDA S_CLASSC
	BNE @NO4
	
	LDA FRET1
	LDY #UND_OFFS
	SEC 
	SBC (CP_ADDR),Y ;take the remainder (gain - UND)/4 and add to the gaining party (not opponents!)
	LSR 
	LSR 
	LDY V_PARTY
	INY 
	CLC 
	ADC (CP_ADDR),Y
	JSR _ADDCPU1
	STA (CP_ADDR),Y
@NO4
	LDY #UND_OFFS
	LDA #00
	STA (CP_ADDR),Y
	RTS 
;check for overflow store (cap to #$FF)
_ADDCPU1 
	BCC @NOVERF
	LDA #$FF
@NOVERF 
	STA (CP_ADDR),Y
	RTS 
;add CP/4 to other candidates
_ADDCPU2 
	LDA FVAR6
	BNE @DONE
	INY 
	CPY #$05
	BNE @WRAP
	LDY #$01
@WRAP 
	INC V_PARTY
	CPY V_PARTY
	BNE @RTS
	DEC V_PARTY
@DONE
	RTS 
@RTS 
	DEC V_PARTY
	TXA 
	LSR 
	LSR 
	CLC 
	ADC (CP_ADDR),Y
	BCC @NOVERF
	LDA #$FF
@NOVERF 
	STA (CP_ADDR),Y
	JMP _ADDCPU2

;calc_issue_bonus(FARG1=state index)
;IS_ADDR set beforehand
;adds issue bonus for current candidate to FRET1
_CISSUEB 
	LDA #$00
	STA V_IBONUS
	LDY #ISSUEC
@TOP 
	DEY 
	BPL @LOOP
	;end of loop
	LDA S_GMMODE
	BEQ @INDBON ;skipped for random mode
; ASL FRET1 ;issue bonus ; 2 in random mode
	JMP @RTS
@INDBON 
	LDA S_PLAYER ;only for 3P game
	CMP #$03
	BNE @RTS
	LDA V_PARTY ;only for 3rd player
	CMP #$02
	BNE @RTS
	
	;ISSUE BONUS + 2 FOR IND
	LDA #$02
	CLC
	ADC V_IBONUS
	STA V_IBONUS
	
@RTS
	LDY FARG1
	LDA #EV_ISSUE
	JSR _EVENTON
	BNE @DOUBLE
	ASL V_IBONUS
@DOUBLE
	LDA V_IBONUS
	JSR _CPADD
	
	RTS 
@LOOP 
	LDA C_ISSUES,Y
	CMP (IS_ADDR),Y
	BNE @PLUS3
	LDA #$03
	CLC
	ADC V_IBONUS
	STA V_IBONUS
	BNE @TOP
@PLUS3 
	TAX 
	DEX 
	TXA 
	CMP (IS_ADDR),Y
	BNE @OFFBY1L
@ADD1 
	INC V_IBONUS
	BNE @TOP
@OFFBY1L 
	INX 
	INX 
	TXA 
	CMP (IS_ADDR),Y
	BNE @TOP
	BEQ @ADD1

;add_cp_to_cost(A=amt) 
;adds CP to the returned CP value
_CPADD 
	CLC 
	ADC FRET1
	STA FRET1
	RTS 

;add_signed_to_unsigned(A=signed value,FSUS2=unsigned value)
;returns to FSUS1
;LOCAL: Y
;caps to [#$00,#$FF]
_ADDSUS 
	TAY 
	CLC 
	ADC FSUS2
	STA FSUS1

	TYA 
	BMI @NEG

	LDA FSUS2
	CMP FSUS1
	BCC @RTS
	BEQ @RTS
	LDA #$FF

	STA FSUS1
	BNE @RTS
@NEG 
	LDA FSUS2
	CMP FSUS1
	BCS @RTS
	LDA #00
	STA FSUS1
@RTS 
	RTS 

;negative(A=value) 
_NEGATIV 
	EOR #$FF
	CLC 
	ADC #$01
	RTS 

;draw_poll(X=REGION) 
;LOCAL: FSTATE, FVAR3, FARG5
_DRWPOLL 
	STX FARG5
	JSR _CLRBL
	INC V_WEEK
	JSR _OFFSHIS
	DEC V_WEEK

	LDA #P_POLLR
	STA GX_CROW
	JSR _GXINCRW
	LDA #P_POLLC
	STA GX_CCOL

	LDA #00
	STA FVAR3
@PNLOOP 
	LDA #P_POLLC
	STA GX_CCOL
	LDX FVAR3
	JSR _DRWPN1
	LDA #VK_PERC
	STA GX_CIND
	JSR _GX_CHAR
	INC FVAR3
	JSR _GXINCRW
;INC GX_CCOL ;space
	LDA FVAR3

	CMP S_PLAYER ;loop per player
	BCC @PNLOOP
	CMP #UND_OFFS
	BEQ @PNDONE

	LDA #UND_OFFS
	STA FVAR3
	DEC FVAR3
	LDA S_DRWUND
	BEQ @PNDONE ;if draw und off, ignore
	JMP @PNLOOP ;if on, add UND


@PNDONE 
;JSR _GXINCRW
	LDX FARG5
	LDA D_REGLIM,X
	STA FVAR3
	DEX 
	LDA D_REGLIM,X
	STA FSTATE
	STA FARG1
	JSR _CPOFFS
	
	LDX FARG5
	INC V_POLL-1,X
	LDA V_POLL-1,X
	STA V_POLDIV
	
	LDA #P_POLLC2
	STA GX_LX1
@LOOP 
	LDA #P_POLLR
	STA GX_CROW
	LDA GX_LX1
	STA GX_CCOL
	
	LDX FSTATE
	LDA V_STCOL,X
	STA GX_DCOL
	LDA FSTATE
	JSR _DRWPOST
	JSR _GXINCRW
	LDA GX_LX1
	STA GX_CCOL
	
	LDY FSTATE
	LDA #EV_COMMS
	JSR _EVENTON
	BEQ @PLDONE
	
	JSR _POPSUMR
	JSR _STATSUM ;get this start-of-week CP, not last week's
	
	LDX FSTATE
	LDA V_CTRL,X
	CMP #UND_PRTY
	BNE @NOMOE
	JSR _POLLOBF
@NOMOE
	LDA #00
	STA FVAR1 ;party count
@PLAYLOOP 
	LDA FVAR1
	ASL 
	TAY 

	JSR _PERCSTA
	LDX FVAR1
	LDA V_PTCOL,X
	STA GX_DCOL

	LDA #00
	STA V_FPOINT+2
	+__LAB2XY V_FPOINT
	JSR _GX_STR
	JSR _GXINCRW
;INC GX_CCOL
	LDA GX_LX1
	STA GX_CCOL

	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER ;loop per player
	BCC @PLAYLOOP
	CMP #UND_OFFS
	BEQ @PLDONE
	LDA #UND_OFFS


	STA FVAR1
	DEC FVAR1
	LDA S_DRWUND
	BEQ @PLDONE ;if draw und off, ignore
	JMP @PLAYLOOP ;if on, add UND
@PLDONE 
	JSR _GXINCRW

	LDA GX_LX1
	CLC 
	ADC #$03
	STA GX_LX1

	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP FVAR3
	BEQ @DONE
	JMP @LOOP
@DONE 
	JSR _FTC
	JSR _CLRBL
	RTS 

;save_history() 
_SAVEHIS 
	JSR _CPOFFR
	LDA #$01
	STA FSTATE

	LDA #>V_HIST
	CLC 
	ADC V_WEEK
	STA OFFSET+1
	LDA #01
	STA OFFSET

	LDY #00
@LOOP 
	LDX #01
@CLOOP 
	STY FY1
	TXA 
	TAY 
	LDA (CP_ADDR),Y
	LDY FY1
	STA (OFFSET),Y
	INX 
	INY 
	CPX #UND_OF1M
	BNE @CLOOP

	INC FSTATE
	JSR _CPOFFI
	LDA FSTATE
	CMP #STATE_C
	BNE @LOOP
	RTS 

;tiebreaker() 
;determines who wins control for a CP tie: 1: ISSUE BONUS -> 2: STATE LEAN -> 3: WON POPULAR VOTE -> 4: COIN FLIP
;POPSUM, CP_ADDR, IS_ADDR set beforehand
;returns A = party index, FRET2 = tie value
;LOCAL: FVAR1-2,FRET1+3,FX1

_TIE 
	JSR _MAXPL
	STX FVAR2 ;number of tied parties
	JSR _MAXR

	LDA #00
	STA FVAR1 ;tied parties index
@TIE1 
	LDX FVAR1
	LDA V_MAXPL,X
	JSR _CANDLOAD
	LDA #00
	STA FRET1
	JSR _CISSUEB
	LDX FVAR1
	TXA 
	ASL 
	TAX 
	LDA FRET1
	STA V_MAX,X

	INC FVAR1
	LDA FVAR1
	CMP FVAR2
	BNE @TIE1

	LDA #$01
	STA FRET3
	JSR _MAX2
	BEQ @GOTOT2
	JMP _TIE2
@GOTOT2 
	LDA #00
	STA FVAR1
@TIE2 
	LDX FVAR1
	LDA V_MAXPL,X
	CLC 
	ADC #UND_OF1M
	TAY 
	LDA FVAR1
	ASL 
	TAX 
	LDA (CP_ADDR),Y
	STA V_MAX,X

	INC FVAR1
	LDA FVAR1
	CMP FVAR2
	BNE @TIE2

	LDA #$02
	STA FRET3
	JSR _MAX2
	BEQ @GOTOT3
	JMP _TIE2
@GOTOT3 
	LDA #$03
	STA FRET3
	
	LDA #00
	STA FVAR1
@TIE3
	LDX FVAR1
	LDA V_MAXPL,X
	CMP V_POPWIN
	BEQ @MATCH
	INC FVAR1
	LDA FVAR1
	CMP FVAR2
	BNE @TIE1
	BEQ @GOTOT4
@MATCH
	JMP _TIE2
@GOTOT4 

	LDA #$04
	STA FRET3
	LDA FVAR2
	JSR _RNG
	CLC 
	ADC #$01
	JMP _TIE2
;return SR
_TIE2 
	TAX 
	DEX
	LDA V_MAXPL,X
	RTS 

;calc_win() 
;determines who won and by what tie level: 1->EC PLURALITY; 2->WON POPULAR VOTE; 3->LMIN; 4->COIN FLIP
;FRET1 = winning party index + 1
;RETURNS A = winning criteria
_CALCWIN 
	LDA #00
	STA FRET1

	LDA #STATE_C
	STA FARG5
	JSR _MAXEC
	BEQ @TIE1
	STA FRET1
	LDA #00
	RTS 
@TIE1 
	JSR _MAXPL ;store EC tie
	STX FAI ;temp store tied party count
	JSR _MAXR

	LDX #00
@LOOP2
	LDA V_MAXPL,X
	CMP V_POPWIN
	BEQ @MOSTPOP
	INX
	CPX FAI
	BNE @LOOP2
	
@MOSTPOP
	STA FRET1
	LDA #01
	RTS 
@TIE2 
	JSR _MAXR

	LDA #00
	STA V_PARTY
@LOOP3 
	LDA V_PARTY
	ASL 
	TAX 
	LDA C_LMIN
	STA V_MAX,X

	JSR _CANDSWAP
	LDA V_PARTY
	BNE @LOOP3

	JSR _CALCWIN2
	JSR _MAX2
	BEQ @TIE3
	STA FRET1
	LDA #02
	RTS 
@TIE3 
	LDX #00
@PLLOOP 
; LDA V_MAXPL,X
; BEQ @PLDONE
; INX
; CPX FAI
; BNE @PLLOOP
@PLDONE 
; TXA
	LDA FAI
	JSR _RNG
	TAX 
	LDA V_MAXPL,X

	STA FRET1
	INC FRET1
	LDA #03
	RTS 

;filter only parties that tied in EC
_CALCWIN2 
	LDX #00
	LDY #00
@LOOP 
	TXA 
	CMP V_MAXPL,Y
	BEQ @SKIP
	PHA 
	ASL 
	TAX 
	LDA #00
	STA V_MAX,X
	STA V_MAX+1,X
	PLA 
	TAX 
	JMP @NOINY
@SKIP 
	INY 
@NOINY 
	INX 
	CPX S_PLAYER


	BNE @LOOP
	RTS 

;calculate_revert_lean() 
;adds CP to unvisited states
_CALCREV 
	LDX #01
	STX FSTATE
@LOOP 
	LDX FSTATE
	LDA V_REVERT,X
	BEQ @SKIP
	STA FVAR3

	STX FARG1
	JSR _CPOFFS
@CUMUL 
	LDY #00
	STY FVAR2
@LOOP2 
	LDY FVAR2
	STY V_PARTY
	TYA 
	CLC 
	ADC #UND_OF1M
	TAY 
	LDA (CP_ADDR),Y
	STA FRET1
	JSR _ADDCPUN
	INC FVAR2
	LDA FVAR2
	CMP S_PLAYER
	BNE @LOOP2

@SKIP 
	INC FSTATE
	LDA FSTATE
	CMP #STATE_C
	BNE @LOOP

	LDX #01
@LOOP3 
	INC V_REVERT,X
	INX 
	CPX #STATE_C
	BNE @LOOP3

	LDA #00
	STA V_PARTY
	RTS 

;save_undecided_cp() 
;saves UND CP value; used for simultaneous calculations
;i.e. UND CP is the same for all candidates during a week
;instead of being executed in party order
_SAVEUND 
	LDA #$01


	STA FARG1
	STA FSTATE
	JSR _CPOFFS
@LOOP 
	LDY #UND_OFFS
	LDA (CP_ADDR),Y
	LDX FSTATE
	STA V_UNDCP,X

	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP #STATE_C
	BNE @LOOP

	RTS 

;average_region_state_lean(V_PARTY = desired party)
_REGLEAN

	LDA #$01
	STA FARG1
	STA FSTATE
	JSR _CPOFFS
@STLOOP
	LDA V_PARTY
	CLC
	ADC #UND_OF1M
	TAY
	LDA (CP_ADDR),Y
	LDX FSTATE
	STA V_CTRL,X ;temp use
	
	INC FSTATE
	JSR _CPOFFI
	LDA FSTATE
	CMP #STATE_C
	BNE @STLOOP

	LDA #$01
	STA FVAR1 ;region
@REGLOOP
	LDX FVAR1
	LDA D_REGLIM-1,X
	STA FVAR5 ;lower limit
	LDA D_REGLIM,X
	STA FVAR6 ;upper limit
	
	LDX FVAR5
	LDY #00
@INREGION	
	LDA V_CTRL,X
	STA V_AISTAT,Y
	INY
	INX
	CPX FVAR6
	BNE @INREGION
	
	+__LAB2O V_AIH2REG-1
	LDX V_PARTY
	LDY #$09
	JSR _OFFSET
	
	LDX FVAR1
	LDA D_REGC-1,X
	STA FARG1
	JSR _AVGVAL
	LDY FVAR1
	STA (OFFSET),Y
	
	INC FVAR1
	LDA FVAR1
	CMP #$0A
	BNE @REGLOOP
	RTS

;we already have state control values, so we know which states are outside MoE. Those numbers remain unaltered. Those that AREN'T must have their state sums modified, but not in excess of the MoE. Since we know that the difference between the top two parties is always less than MoE, Therefore, it makes sense to 1) decrease the largest party's count by [0,-MoE/2 + 1] to a minimum of 1, 2) increase all other parties by [0,MoE/2 - 1] to a maximum of 255, where MoE is (total CP * MoE).
;poll_obfuscate()
_POLLOBF
	;do MoE / 100
	LDA #$00
	LDY V_MOE
	JSR _162FAC
	JSR _FDIV10
	JSR _FDIV10
	JSR _FAC2ARG
	;multiply MoE by STATSUM total
	LDA #$00
	LDY V_POPSUM+10
	JSR _162FAC
	JSR _FMULTT
	;convert back to hex
	LDA #00 ;no negatives!
	STA $A2
	STA $AA
	JSR _FAC232 ;float FAC to 32bit
	;generate [party] random amounts
	LDX S_PLAYER
@RANDOM
	DEX
	LDA FAC+4
	LSR
	;halve MoE [# of times region has been POLLed - 1]
	LDY V_POLDIV
	DEY
@HALVING
	CPY #00
	BEQ @DONEHALF
	LSR
	DEY
	JMP @HALVING
@DONEHALF
	CMP #$02
	BCC @ZERO
	JSR _RNG
@ZERO
	STA FAC,X
	CPX #$00
	BNE @RANDOM
	;add/subtract to STATSUM values
	JSR _MARGMAX ;get highest party
	CMP #$00
	BEQ @TIE
	
	TAX
	DEX
	LDA FAC,X
	JSR _NEGATIV ;set only highest to negative
	STA FAC,X
	JMP @ADD
@TIE
	LDX #00 ;set random parties to negative
@TIELOOP 
	LDA #$02
	JSR _RNG
	BNE @FLIP
	LDA FAC,X
	JSR _NEGATIV
	STA FAC,X
@FLIP
	INX
	CPX S_PLAYER
	BNE @TIELOOP
@ADD
	LDX #00
	LDY #00
	STX V_POPSUM+10
	STX V_POPSUM+11 ;reset total and re-sum
@ADDLOOP	
	LDA V_POPSUM,Y
	STA FSUS2
	LDA FAC,X
	STY FY1
	JSR _ADDSUS
	LDY FY1
	LDA FSUS1
	STA V_POPSUM,Y
	CLC
	ADC V_POPSUM+10
	STA V_POPSUM+10
	BCC @CARRY
	INC V_POPSUM+11
@CARRY
	
	INX
	INY
	INY
	CPX S_PLAYER
	BNE @ADDLOOP
	
	RTS

;returns the party with the most EC
_MAXEC
	LDA #STATE_C
	STA FARG5
	JSR _SUMEC
	JSR _MAXR
	LDX #00
@LOOP1 
	LDA V_SUMEC,X
	STA V_MAX,X
	INX 
	CPX #$08
	BNE @LOOP1
	JSR _MAX2
	RTS

;popular_vote_sum(FARG5 = state count)
;awards ((EC-2) * state percent) for each state to each party
_POPSUM2
	LDA #00
	LDX #00
@CLEAR
	STA V_POPULAR,X
	INX
	CPX #26
	BNE @CLEAR

	LDA #$01
	STA FARG1
	STA FSTATE
	JSR _CPOFFS
@STATELP
	JSR _POPSUMR
	JSR _STATSUM

	LDA #00
	STA V_PARTY
@PARTYLP
	LDA V_PARTY
	ASL
	TAY
	JSR _PERCSTA2 ;move popsum to percentage arguments
	JSR _PERCEN2 ;calculate percentage to FAC (do not convert to string)
	JSR _FAC2ARG
	LDX FSTATE
	LDA V_EC,X
	SEC
	SBC #$02
	TAY
	LDA #00
	JSR _162FAC ;EC - 2 to FAC
	JSR _FMULTT ;percentage * (EC - 2)
	
	LDY V_PARTY
	JSR _POP2OFF
	LDY OFFSET+1
	LDA OFFSET
	JSR _FADD ;add to sum
	LDY OFFSET+1
	LDX OFFSET
	JSR _MOVMF ;move new sum back
	
	INC V_PARTY
	LDA V_PARTY
	CMP S_PLAYER
	BCC @PARTYLP
	
	LDA S_SUMUND
	BEQ @DONEPT
	
	LDA V_PARTY
	CMP #UND_PRTY+1
	BEQ @DONEPT
	
	LDA #UND_PRTY
	STA V_PARTY
	BNE @PARTYLP
	
@DONEPT
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP FARG5
	BNE @STATELP
	
	LDA #00
	STA V_PARTY
	RTS

;popular_percentage_by_party(FARG1 = party index)
;finds the percentage of the total popular vote for one party
;LOCAL: FVAR6
_POPSUM2P	
	LDY FARG1
	JSR _POP2OFF
	LDY OFFSET+1
	LDA OFFSET
	JSR _MOVFM
	JSR _FAC2F3
	
	LDA S_SUMUND
	BEQ @SUM
	LDY #$B4
	LDA #$01 ;436
	JSR _162FAC
	JMP @DIV
@SUM ;sum all popular vote float values
	+__LAB2O V_POPULAR
	LDY OFFSET+1
	LDA OFFSET
	JSR _MOVFM
	
	LDA #01
	STA FVAR6
@LOOP
	LDX #$01 ;advance to next float value
	LDY #FLOATLEN
	JSR _OFFSET
	LDY OFFSET+1
	LDA OFFSET
	JSR _FADD
	
	INC FVAR6
	LDA FVAR6
	CMP S_PLAYER
	BNE @LOOP
@DIV
	JSR _F32ARG
	JSR _DIVIDE
	JSR _FAC2STR
	;JSR _PERCFMT
	RTS
	
;state_cp_sum() 
;sums all candidates' CP at current CP_ADDR/HS_ADDR
;if draw_und is set, adds UND to total as well
;adds result to V_POPSUM; for single-use, clear first
_STATSUM 
	LDY #01
@LOOP 
	JSR _STATSM2
	CLC 
	ADC V_POPSUM+10
	STA V_POPSUM+10
	BCC @NOC
	INC V_POPSUM+11
@NOC 
	DEY 
	TYA 
	ASL 
	TAX 
	INY 
	JSR _STATSM2
	CLC 
	ADC V_POPSUM,X
	STA V_POPSUM,X
	BCC @NOC2
	INC V_POPSUM+1,X
@NOC2 
	INY 
	CPY S_PLAY1M ;loop per player
	BCC @LOOP
	CPY #UND_OF1M
	BEQ @RTS

	LDY #UND_OFFS
	LDA S_SUMUND
	BEQ @RTS ;if draw und off, ignore
	JMP @LOOP ;if on, add UND
@RTS 
	RTS 
;sum from history check
_STATSM2 
	LDA V_SUMFH
	BEQ @FROMCP
	LDA (HS_ADDR),Y
	RTS 
@FROMCP 
	LDA (CP_ADDR),Y
	RTS 

;percent_state(Y = party index * 2)
;divides state CP by total, formats
_PERCSTA 
	JSR _PERCSTA2
	JSR _PERCENT
	RTS 
_PERCSTA2
	LDA V_POPSUM,Y
	STA FARG1
	LDA V_POPSUM+1,Y
	STA FARG2
	LDA V_POPSUM+10
	STA FARG3
	LDA V_POPSUM+11
	STA FARG4
	RTS

;state_control_count(A = party)
;counts the number of states party A is winning
;(only on the map)
;returns to A
;LOCAL: FRET1,FY1
_CTRLCNT 
	TAY 
	STY FY1
	LDX #01
	LDA #00
	STA FRET1
@LOOP 
	LDA V_CTRL,X
	CMP FY1
	BNE @SKIPADD
	INC FRET1
@SKIPADD 
	INX 
	CPX #STATE_C
	BNE @LOOP
	RTS 

;popsum_draw_combo() 
_POPCOM1
	JSR _POPSUM2
	LDA S_SKIPGAME
	BNE @RTS
	LDA #STATE_C
	STA FARG5
	JSR _DRWPOP
@RTS
	RTS 
	
;candidate_display_loop() 
;shows all candidates
_CANDLOOP 
	LDA #$00
	STA V_REDRW1
	STA V_PARTY
	JSR _CANDLOAD
@LOOP 
	JSR _DRWCAND
	JSR _CANDSWAP
	JSR _FTC
	LDA V_PARTY
	BNE @LOOP
	RTS 

;pop_sum_reset() 
;clears V_POPSUM
_POPSUMR 
	LDX #00
	LDA #00
@LOOPCLR STA V_POPSUM,X
	INX 
	CPX #$0C
	BNE @LOOPCLR
	RTS 

;popular_vote_sum() 
;draw_und set beforehand
;sums ALL state cp by party, returns to v_popsum
_POPSUM 
	LDA #00
	STA HS_ADDR
	LDA #$01
	STA FSTATE
	JSR _CPOFFR
@STLOOP

	JSR _STATSUM
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP #STATE_C
	BNE @STLOOP
	RTS 


;max2nd() 
;max2() but instead gets the second highest value
;only guaranteed a second value, not a second party
;quits if initial tie
_MAX2ND
	JSR _MAX2
	
	BEQ @TIE
	ASL 
	TAY 
	DEY 
	DEY 
	LDA #$00
	STA V_MAX,Y
	STA V_MAX+1,Y
	JSR _MAX2
@TIE 
	RTS 

;max2() 
;2B maximum where values are (L)(H) pairs in V_MAX
;LOCAL: FRET1-2
;returns to MAXLOW/MAXHIGH; if not tie, A = index
_MAX2 
	LDX #01
	JSR _MAXA
	LDX #01
	JSR _MAXB
	PHA 
	LDA FRET1
	STA MAXHIGH
	PLA 
	BNE @NOTTIE
	LDX #00
	JSR _MAXA
	LDX #00
	JSR _MAXB
	PHA 
	LDA FRET1
	STA MAXLOW
	PLA 
@NOTTIE 
	RTS 

;max_a(x = V_MAX offset)
;FRET1 = maximum value
;put maximum value in FRET1
_MAXA 
	LDY #$01
	LDA #00
	STA FRET1
	STA FRET2
@LOOP 
	LDA V_MAX,X
	CMP FRET1
	BCC @SKIPSTA
	STA FRET1
@SKIPSTA 
	INX 
	INX 
	INY 
	CPY S_PLAY1M
	BNE @LOOP

	RTS 


;max_b(X = V_MAX offset)
;returns A = index + 1 (0 for tie)
_MAXB 

	LDY #01
@RLOOP 
	LDA V_MAX,X
	CMP FRET1
	BNE @SKIP
	LDA FRET2
	BNE @TIE
	STY FRET2
@SKIP 
	INX 
	INX 
	INY 
	CPY S_PLAY1M
	BNE @RLOOP

	LDA FRET2
	RTS 
@TIE 
	LDA #00
	RTS 

;max_reset() 
_MAXR 
	LDX #00
	LDA #00
@LOOP 
	STA V_MAX,X
	INX 
	CPX #$08
	BNE @LOOP
	RTS 

;und_setup() 
_UNDCP 
	JSR _CPOFFR
	LDA #01
	STA FSTATE
@LOOP 
	LDX FSTATE
	LDA #147
	CLC 
	ADC V_EC,X
	ADC V_EC,X
	;255 - (54 - EC);2 = 147 + EC;2
	LDY #UND_OFFS
	STA (CP_ADDR),Y
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP #STATE_C
	BNE @LOOP
	RTS 
	
;color_map() 
;maps party control for all states to map color
;does NOT set party control -- use _STCTRL or _FINALCP
_MAPCOL 
	JSR _CPOFFR
	LDA #01
	STA FSTATE
@LOOP 
	LDX FSTATE
	LDA V_CTRL,X
	TAY 
	LDA V_PTCOL,Y
	STA V_STCOL,X

	LDA V_COLMSK,X
	BEQ @SKIPMSK ;if mask is nonzero, blank state
	LDY #UND_PRTY
	LDA V_PTCOL,Y
	STA V_STCOL,X
@SKIPMSK 

	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP #STATE_C
	BNE @LOOP
	RTS 
	
;skip_game_check()
;if all players are AIs AND quick game is on, activates S_SKIPGAME
_SKIPCHK
	LDA S_QUICKG
	BEQ @RTS
	LDX #00
@LOOP
	LDA V_AI,X
	BEQ @RTS
	INX
	CPX S_PLAYER
	BNE @LOOP
	LDA #$01
	STA S_SKIPGAME
@RTS	
	RTS

;clears poll-by-region counts
_CLRPOLL
	LDX #$00
	STX V_POLLCT
@CLR3
	STA V_POLL,X
	INX
	CPX #REGION_C
	BNE @CLR3
	RTS
	
;calculate_popular_vote_winner()
;POPSUM called beforehand
;stores winning party index + 1 to V_POPWIN
_POPWIN
	LDA #00
	STA FVAR1
	LDA #00
	LDY #00
	JSR _162FAC ;FAC = 0
@TIE3 
	LDY FVAR1
	JSR _POP2OFF ;V_POPULAR should be loaded
	LDA OFFSET
	LDY OFFSET+1
	JSR _FCOMP
	CMP #$FF
	BNE @LESSEQ
	LDA OFFSET
	LDY OFFSET+1
	JSR _MOVFM ;set new maximum to FAC
@LESSEQ
	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER
	BNE @TIE3
	;max popular vote value is in FAC
	LDA #00
	STA FVAR1
	LDA #$FF
	STA FX1 ;party list index (must be set to an index; if it is set twice, quit)
@TIE3L2 
	LDY FVAR1
	JSR _POP2OFF
	LDA OFFSET
	LDY OFFSET+1
	JSR _FCOMP
	CMP #00
	BNE @NOTMAX
	LDX FX1
	CPX #$FF
	BNE @FALSE ;quit
	LDX FVAR1
	STX FX1
@NOTMAX
	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER
	BNE @TIE3L2
	LDX FX1
	INX
	TXA
	JMP @RTS
@FALSE
	LDA #00
@RTS
	STA V_POPWIN
	RTS