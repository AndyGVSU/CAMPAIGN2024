;ccalc.asm
;CAMP02 
;game math

;detailed_results(FSTATE = state)
;draws history results for a state
;LOCAL: FVAR1
_DETAIL 
	JSR _MAXR
	LDA #$01
	STA V_SUMFH
	LDA FSTATE
	JSR _CPOFFS
	JSR _GX_CLRS
	;draw header
	LDA #P_LEFT
	STA GX_CCOL
	LDA #P_DETSTR
	STA GX_CROW
	LDA #C_LBLUE
	STA GX_DCOL
	LDA FSTATE
	JSR _DRWPOST
	INC GX_CCOL
	+__LAB2XY T_HIST
	JSR _GX_STR

	LDA #P_DETLHR
	STA GX_CROW
	LDA #P_LEFT
	STA GX_CCOL
	
	LDA #23 ;W
	JSR _GX_STR2
	
	LDA #00
	STA FVAR1
@HEADERLP
	INC GX_CCOL
	LDX FVAR1
	JSR _DRWPN3
	INC FVAR1
	LDX FVAR1
	CPX S_PLAYER
	BNE @HEADERLP
	
	INC GX_CCOL
	
	+__LAB2XY T_DETAILED
	JSR _GX_STR
	
	INC GX_CCOL
	INC GX_CCOL
	INC GX_CCOL
	
	+__LAB2XY T_RATINGS2+10
	JSR _GX_STR
	
	LDA #01
	STA V_WEEK
	LDA #P_DETLR
	STA GX_CROW
@WEEKLOOP 
	JSR _HSOFFS
	LDX FSTATE
	JSR _HSOFFS2
	;draw row
	LDA #P_LEFT
	STA GX_CCOL
	;draw row
	
	LDA V_WEEK
	CMP #WEEKMAX+1
	BEQ @FINALW
	CMP #WEEKMAX+2
	BEQ @TOTAL
	
	ORA #$30
	BNE @NOTFIN
@FINALW 
	LDA #$4C ;L
	BNE @NOTFIN
@TOTAL
	INC GX_CROW
	JMP @FIN
@NOTFIN 
	STA GX_CIND
	LDA #C_WHITE
	STA GX_DCOL
	JSR _GX_CHAR
@FIN
	LDA #01
	STA V_MARGIN
	JSR _PCTRL ;calculates all fixed margins AND the actual margin
	STA FVAR4 ;winner index
	
	LDY #00
	STY FVAR1 ;party index
	INC GX_CCOL
@PTLOOP 
	INC GX_CCOL

	LDY FVAR1
	LDA V_PTCOL,Y
	STA GX_DCOL
	
	LDX FVAR1
	JSR _LDAFPERC
	JSR _PERCTRUNC
	LDX FVAR1
	LDA V_PTCOL,X
	STA GX_DCOL

	+__LAB2XY V_FPOINT
	JSR _GX_STR
	
	INC FVAR1
	LDY FVAR1
	CPY S_PLAYER
	BNE @PTLOOP

	INC GX_CCOL
	LDA FVAR4
	CMP #UND_PRTY
	BEQ @TIE
	STA FX1

	LDX FX1
	JSR _DRWPN1
	LDA #$2B ;+
	STA GX_CIND
	JSR _GX_CHAR

	INC GX_CCOL
	LDA #<V_MARGINF
	LDY #>V_MARGINF
	JSR _MOVFM
	JSR _FDIV10
	JSR _FDIV10
	JSR _STRPERC
	+__LAB2XY V_FPOINT
	JSR _GX_STR
	JMP @SKIPTIE
@TIE 
	+__LAB2XY T_TIE
	JSR _GX_STR
@SKIPTIE
	JSR _DRWSPAC
	JSR _LEANDIF2
	JSR _LEANDIF3
	LDX FRET1
	JSR _DRWRATING2
 
	INC GX_CROW
	INC V_WEEK
	LDA V_WEEK
	CMP #WEEKMAX+2
	BEQ @HISTOFF
	CMP #WEEKMAX+3
	BEQ @RTS
	JMP @WEEKLOOP
@RTS
	RTS
@HISTOFF
	LDA #00
	STA V_SUMFH
	JMP @WEEKLOOP

;mask() 
;blanks map
_FILMASK 
	LDA #01
	TAX 
@LOOP 
	STA V_COLMSK,X
	INX 
	CPX #STATE_C
	BNE @LOOP
	RTS 

;sum_ec(FARG5 = state limit (usually STATE_C))
;sums EC by party control
_SUMEC2
	LDA #STATE_C
	STA FARG5
_SUMEC 
	LDA #00
	TAX 
@CLR 
	STA V_SUMEC,X
	INX 
	CPX #$0A
	BNE @CLR
	TAX 

	LDY #01
	STY FSTATE
@LOOP 
	LDX FSTATE
	JSR _LDACTRL
	ASL 
	TAX 
	LDA V_SUMEC,X
	LDY FSTATE
	CLC 
	ADC V_EC,Y
	STA V_SUMEC,X
	BCC @CARRY
	INC V_SUMEC+1,X
@CARRY 

	INC FSTATE
	LDA FSTATE
	CMP FARG5
	BNE @LOOP
	
	;calculate landslide
	LDA #00
	STA FPARTY
	STA V_LANDSLIDE
@LANDSLIDE
	LDA FPARTY
	ASL
	TAX
	LDA V_SUMEC,X
	TAY
	LDA V_SUMEC+1,X
	JSR _162FAC
	LDA #<V_PLURALF
	LDY #>V_PLURALF
	JSR _FCOMP
	BMI @SKIP
	LDX FPARTY
	INX
	STX V_LANDSLIDE
@SKIP
	INC FPARTY
	LDA FPARTY
	CMP S_PLAYER
	BNE @LANDSLIDE
	RTS 

;state_get_region(A=state index)
;returns region to X
_STATEGR 
	LDX #00
@LOOP 
	INX
	CMP D_REGLIM,X
	BCS @LOOP
	RTS 

;national_campaign(FARG1 = extra region, FARG2 = base value)
;for pregame / lastminute -- all states
;directly adds base value CP + issue bonus at no cost UNLESS V_FRINGE
;LOCAL: FARG3
_NATCAMP 
	LDX V_PARTY
	LDA V_FRINGE,X
	BEQ @FRINGE
	RTS
@FRINGE
	
	LDA FARG1
	STA FARG3

	LDA #STATE_C
	STA HIGHSTATE
	LDA #01
	STA FSTATE
@OFFSET 
	JSR _CPOFFS
@LOOP 
	LDA FSTATE
	STA FARG1
	JSR _CISSUEB
	ASL 
	CLC 
	ADC FARG2
	LSR ;(issue bonus * 2 + base) / 2 
	STA FRET1
	
	JSR _ADDCP
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP HIGHSTATE
	BNE @LOOP

	LDX FARG3
	BEQ @RTS
	
	JSR _LREGLIM
	LDA #00
	STA FARG3
	LDA LOWSTATE
	STA FSTATE
	JMP @OFFSET
@RTS 
	RTS 

;pregame_campaign() 
;national campaign for beginning of game
_PRECAMP 
	LDA C_CER
	STA FARG2
	LDA C_CREG
	STA FARG1
	JSR _NATCAMP
	JSR _CANDSWAP
	LDA V_PARTY
	BNE _PRECAMP

	JSR _MAPCOL
	RTS 

;postgame_campaign() 
;national campaign for end of game
_PSTCAMP 
	LDA C_LMIN
	ASL
	CLC 
	ADC C_CER ;base = CER + LMIN * 2
	STA FARG2
	LDA C_CREG
	STA FARG1
	JSR _NATCAMP
	JSR _CANDSWAP
	LDA V_PARTY
	BNE _PSTCAMP

	JSR _MAPCOL
	RTS 

;add_cp(FRET1 = CP GAIN)
;CP is added to index V_PARTY
_ADDCP
	LDA FRET1
	JSR _ADDCP2
@RTS
	RTS 
;add_cp(CP_ADDR set, A = CP gain)
;does the actual adding
_ADDCP2
	BEQ @RTS ;if CP gain is zero, quit
	STA FVAR3 ;added CP
	LDY V_PARTY
	LDA (CP_ADDR),Y
	JSR _GETLEVEL
	STX FVAR1 ;current level
	LDA FVAR3
	JSR _MULTLEVEL
	CLC
	ADC (CP_ADDR),Y
	BEQ @RTS ;cap to $FF
	STA FVAR2 ;hypothetical final CP 
	LDX FVAR1
	CLV
	SEC
	SBC D_CPLEVEL,X
	BVS @DONE
	BPL @CARRYOVER
	JMP @DONE
@CARRYOVER
	INC FVAR1 ;level + 1
	LDX FVAR1
	JSR _MULTLEVEL
	LDX FVAR1
	DEX
	CLC
	ADC D_CPLEVEL,X
	STA (CP_ADDR),Y
	TYA
	CLC
	ADC #CPBLEAN
	TAY
	LDA (CP_ADDR),Y
	CLC
	ADC #$01
	CMP #16
	BEQ @SKIP
	STA (CP_ADDR),Y ;SL + 1
@SKIP 
	JMP @RTS
@DONE
	LDA FVAR2 
	STA (CP_ADDR),Y
@RTS
	RTS

;get_cp_level(A = CP)
;determines the current level based on current CP
;returns X = level
_GETLEVEL
	LDX #00
	CMP D_CPLEVEL+0
	BCC @RTS
	INX
	CMP D_CPLEVEL+1
	BCC @RTS
	INX
	CMP D_CPLEVEL+2
	BCC @RTS
	INX
	CMP D_CPLEVEL+3
	BCC @RTS
	INX
@RTS
	RTS
	
;apply_level_multiplier(A = CP, X = level)
;halves A X times (to 1 at minimum)
_MULTLEVEL
	CPX #04
	BCS @ONE
@LOOP
	CPX #00
	BEQ @DONE
	LSR
	DEX
	BNE @LOOP
@DONE
	CMP #00
	BEQ @ONE
	RTS
@ONE
	LDA #01
	RTS
	
;calc_issue_bonus(FARG1=state index)
;max issue bonus is 10, but is calculated out of 20
;IS_ADDR set beforehand
;returns issue bonus out of 20 in V_IBONUS, A = issue bonus out of 10
_CISSUEB 
	LDA #$00
	STA V_IBONUS
	LDY #ISSUEC
@TOP 
	DEY 
	BPL @LOOP
	;end of loop
	LDA V_IBONUS
	BPL @MINCAP
	LDA #00
@MINCAP
	STA V_IBONUS
	
	LDY FARG1
	LDA #EV_ISSUE
	JSR _EVENTON
	BNE @DOUBLE
	ASL V_IBONUS
@DOUBLE
	LDA V_IBONUS
	LSR
	RTS 
@LOOP 
	LDA C_ISSUES,Y
	CMP #ISSUEX
	BEQ @ISSUEX
	CMP #ISSUEN
	BEQ @ISSUEN

	LDA (IS_ADDR),Y
	SEC
	SBC C_ISSUES,Y
	BPL @NEG
	JSR _NEGATIV
@NEG
	CMP #03
	BCS @ZERO
	CMP #00
	BEQ @BEST
	CMP #01
	BEQ @MID
@LOW
	LDA #01
	BNE @STA
@MID
	LDA #02
	BNE @STA
@BEST
	LDA #04
	BNE @STA
@ZERO
	LDA #00
	BEQ @STA
@ISSUEX
	LDA #$02
	JMP @STA
@ISSUEN
	LDA #$FF
	JMP @STA
@STA
	CLC
	ADC V_IBONUS
	STA V_IBONUS
	JMP @TOP

;add_cp_to_cost(A=amt) 
;adds CP to the returned CP value
_CPADD 
	CLC 
	ADC FRET1
	STA FRET1
	RTS 

;add_signed_to_unsigned(A=signed value,FSUS2=unsigned value)
;returns to FSUS1
;LOCAL: Y
;caps to [#$00,#$FF]
_ADDSUS 
	TAY 
	CLC 
	ADC FSUS2
	STA FSUS1

	TYA 
	BMI @NEG

	LDA FSUS2
	CMP FSUS1
	BCC @RTS
	BEQ @RTS
	LDA #$FF

	STA FSUS1
	BNE @RTS
@NEG 
	LDA FSUS2
	CMP FSUS1
	BCS @RTS
	LDA #00
	STA FSUS1
@RTS 
	RTS 

;negative(A=value) 
_NEGATIV 
	EOR #$FF
	CLC 
	ADC #$01
	RTS 

;draw_poll(X=REGION) 
;LOCAL: FSTATE, FVAR3, FARG5
_DRWPOLL 
	STX FARG5
	JSR _CLRBL

	LDA #P_POLLR
	STA GX_CROW
	INC GX_CROW
	LDA #P_POLLC
	STA GX_CCOL

	LDA #00
	STA FVAR3
@PNLOOP 
	LDA #P_POLLC
	STA GX_CCOL
	LDX FVAR3
	JSR _DRWPN1
	LDA #VK_PERC
	STA GX_CIND
	JSR _GX_CHAR
	INC FVAR3
	INC GX_CROW
	LDA FVAR3

	CMP S_PLAYER ;loop per player
	BNE @PNLOOP
	
	LDX FARG5
	JSR _LREGLIM
	LDA LOWSTATE
	STA FSTATE
	JSR _CPOFFS

	LDA #P_POLLC2
	STA GX_LX1
@LOOP 
	LDA #P_POLLR
	STA GX_CROW
	LDA GX_LX1
	STA GX_CCOL
	
	LDX FSTATE
	LDA V_STCOL,X
	STA GX_DCOL
	LDA FSTATE
	JSR _DRWPOST
	INC GX_CROW
	LDA GX_LX1
	STA GX_CCOL

	LDA #00
	STA V_MARGIN
	JSR _PCTRL
	;ignore output; just need the fixed percentages
	LDA #00
	STA FVAR1 ;party count
@PLAYLOOP 
	LDX FVAR1
	JSR _LDAFPERC
	JSR _PERCTRUNC
	
	LDX FVAR1
	LDA V_PTCOL,X
	STA GX_DCOL

	LDA #00
	STA V_FPOINT+2
	+__LAB2XY V_FPOINT
	JSR _GX_STR
	INC GX_CROW
	LDA GX_LX1
	STA GX_CCOL

	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER ;loop per player
	BCC @PLAYLOOP
@PLDONE 
	INC GX_CROW

	LDA GX_LX1
	CLC 
	ADC #$03
	STA GX_LX1

	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP HIGHSTATE
	BEQ @DONE
	JMP @LOOP
@DONE 
	JSR _FTC
	JSR _CLRBL
	RTS 

;save_history() 
_SAVEHIS 
	JSR _CPOFFR

	JSR _HSOFFS
@LOOP
	LDY #00
	LDX #00
@CLOOP 
	LDA (CP_ADDR),Y
	STA (HS_ADDR),Y
	INY 
	CPY #CPBLEAN
	BNE @CLOOP
	
	LDX #CPBLEAN
@PACKSL
	STY FY1
	TXA
	TAY
	LDA (CP_ADDR),Y
	STA V_NIBBLE+0
	INY
	LDA (CP_ADDR),Y
	STA V_NIBBLE+1
	JSR _NIBBLE
	LDY FY1
	STA (HS_ADDR),Y
	INY
	INX
	INX
	CPX #CPBLOCK
	BNE @PACKSL
	
	LDX CPSTATE
	LDA V_NEGLECT,X
	STA (HS_ADDR),Y
	
	JSR _HSOFFI
	JSR _CPOFFI

	BNE @LOOP
	RTS 

;tiebreaker() 
;determines who wins control for a tie:
;1: STATE LEAN -> 2: HQ COUNT -> 3: ISSUE BONUS -> 4: WON POPULAR VOTE -> 5: COIN FLIP
;POPSUM, CP_ADDR, IS_ADDR set beforehand
;returns A = party index, FRET3 = tie value
;LOCAL: FVAR1-2,FRET1+3,FX1
_TIE 
	JSR _MAXPL
	STX FVAR2 ;number of tied parties
	JSR _MAXR

	LDA #00
	STA FRET3
@TIELOOP
	LDA #00
	STA V_MAXPLI
	JSR _MAXR
	
	LDA FRET3
	+__LAB2XY D_TIES
	JSR _TABLJSR

	BNE @WINNER
	INC FRET3
	JMP @TIELOOP
@WINNER
	TAX 
	DEX
	LDA V_MAXPL,X
	INC FRET3
	RTS 
;returns index of V_MAXPL with highest SL
_TIESL
@TIE2 
	LDX V_MAXPLI
	LDA V_MAXPL,X
	CLC 
	ADC #CPBLEAN
	TAY 
	LDX V_MAXPLI
	LDA (CP_ADDR),Y
	STA V_MAX1B,X

	INC V_MAXPLI
	LDA V_MAXPLI
	CMP FVAR2
	BNE @TIE2
	JSR _MAX2B
	RTS
;..
_TIEISSUE
@TIE1 
	LDX V_MAXPLI
	LDA V_MAXPL,X
	JSR _CANDLOAD
	LDY CPSTATE
	STY FARG1
	JSR _CISSUEB
	LDX V_MAXPLI 
	LDA V_IBONUS ;use out-of-20 for more precision
	STA V_MAX1B,X

	INC V_MAXPLI
	LDA V_MAXPLI
	CMP FVAR2
	BNE @TIE1
	JSR _MAX2B
	RTS
_TIEHQ
@LOOP
	LDX V_MAXPLI
	LDA V_MAXPL,X
	TAX
	LDY CPSTATE
	JSR _LDAHQ
	LDX V_MAXPLI
	STA V_MAX1B,X
	INC V_MAXPLI
	LDA V_MAXPLI
	CMP FVAR2
	BNE @LOOP
	JSR _MAX2B
	RTS
_TIEPOP
@TIE3
	LDX V_MAXPLI
	LDA V_MAXPL,X
	CLC
	ADC #$01
	CMP V_POPWIN
	BEQ @MATCH
	
	INC V_MAXPLI
	LDA V_MAXPLI
	CMP FVAR2
	BNE @TIE3
	LDA #00
	RTS
@MATCH
	LDX V_MAXPLI
	INX
	TXA
	RTS
_TIECOIN
	LDA FVAR2
	JSR _RNG
	CLC 
	ADC #$01
	RTS
;calc_win() 
;determines who won and by what tie level: 1->EC PLURALITY; 2->WON POPULAR VOTE; 3->LMIN; 4->COIN FLIP
;FRET1 = winning party index + 1
;RETURNS A = winning criteria
_CALCWIN 
	LDA #00
	STA FRET1

	LDA #STATE_C
	STA FARG5
	JSR _MAXEC
	BEQ @TIE1
	STA FRET1
	LDA #00
	RTS 
@TIE1 
	JSR _MAXPL ;store EC tie
	STX FAI ;temp store tied party count
	JSR _MAXR

	LDX #00
@LOOP2
	LDA V_MAXPL,X
	CLC
	ADC #$01
	CMP V_POPWIN
	BEQ @MOSTPOP
	INX
	CPX FAI
	BNE @LOOP2
	BEQ @TIE2
@MOSTPOP
	STA FRET1
	LDA #01
	RTS 
@TIE2 
	JSR _MAXR

	LDA #00
	STA V_PARTY
@LOOP3 
	LDA V_PARTY
	ASL 
	TAX 
	LDA C_LMIN
	STA V_MAX,X

	JSR _CANDSWAP
	LDA V_PARTY
	BNE @LOOP3

	JSR _CALCWIN2
	JSR _MAX2
	BEQ @TIE3
	STA FRET1
	LDA #02
	RTS 
@TIE3 
	LDX #00
@PLLOOP 
@PLDONE 
	LDA FAI
	JSR _RNG
	TAX 
	LDA V_MAXPL,X

	STA FRET1
	INC FRET1
	LDA #03
	RTS 

;filter only parties that tied in EC
_CALCWIN2 
	LDX #00
	LDY #00
@LOOP 
	TXA 
	CMP V_MAXPL,Y
	BEQ @SKIP
	PHA 
	ASL 
	TAX 
	LDA #00
	STA V_MAX,X
	STA V_MAX+1,X
	PLA 
	TAX 
	JMP @NOINY
@SKIP 
	INY 
@NOINY 
	INX 
	CPX S_PLAYER

	BNE @LOOP
	RTS 

;returns the party with the most EC
_MAXEC
	JSR _SUMEC2
	JSR _MAXR
	LDX #00
@LOOP1 
	LDA V_SUMEC,X
	STA V_MAX,X
	INX 
	CPX #$08
	BNE @LOOP1
	JSR _MAX2
	RTS

;popular_vote_sum(FARG5 = state count)
;awards ((EC-2) * state percent) for each state to each party
;calculates and stores total popular vote per party
_POPSUM
	LDA #00
	LDX #00
@CLEAR
	STA V_CPFLOAT,X
	INX
	CPX #FLOATLEN*5
	BNE @CLEAR

	LDA #$01
	STA FSTATE
	JSR _CPOFFS
	
@STATELP
	LDA #$00
	STA V_MARGIN
	STA V_RANDCP
	JSR _PCTRL
	
	LDA #00
	STA FPARTY
@PARTYLP
	LDX FPARTY
	JSR _LDAFPERC
	JSR _FAC2ARG
	LDX FSTATE
	LDA V_EC,X
	CMP #$02 ;if EC < 2, ignore
	BCC @TOOSMALL
	SEC
	SBC #$02
	TAY
	LDA #00
	JSR _162FAC ;EC - 2 to FAC
	JSR _MULTIPLY ;percentage * (EC - 2)

	LDY FPARTY
	JSR _FLT2OFF
	LDY OFFSET+1
	LDA OFFSET
	JSR _MEM2ARG
	JSR _FADDFLAG ;add to sum
@TOOSMALL
	LDY OFFSET+1
	LDX OFFSET
	JSR _MOVMF ;move new sum back

	INC FPARTY
	LDA FPARTY
	CMP S_PLAYER
	BNE @PARTYLP
	
	JSR _CPOFFI
	INC FSTATE
	LDA FSTATE
	CMP FARG5
	BNE @STATELP

	LDA #00
	STA FARG1
@PLAYLOOP
	JSR _POPSUMPT
	JSR _STRPERC
	+__LAB2O V_POPVOTE
	LDX FARG1
	LDY #PERCLEN
	JSR _OFFSET
	LDY #00
@COPY
	LDA V_FPOINT,Y
	STA (OFFSET),Y
	INY
	CPY #PERCLEN
	BNE @COPY
	INC FARG1
	LDA FARG1
	CMP S_PLAYER
	BNE @PLAYLOOP

	RTS

;popular_percentage_by_party(FARG1 = party index)
;finds the percentage of the total popular vote for one party
;LOCAL: FVAR6
_POPSUMPT
	LDY FARG1
	JSR _FLT2OFF
	LDY OFFSET+1
	LDA OFFSET
	JSR _MOVFM
	JSR _FAC2F3
	
	LDY #$B4
	LDA #$01 ;436
	JSR _162FAC
;sum all popular vote float values
	+__LAB2O V_CPFLOAT
	LDY OFFSET+1
	LDA OFFSET
	JSR _MOVFM
	
	LDA #01
	STA FVAR6
@LOOP
	LDX #$01 ;advance to next float value
	LDY #FLOATLEN
	JSR _OFFSET
	LDY OFFSET+1
	LDA OFFSET
	JSR _MEM2ARG
	JSR _FADDFLAG
	
	INC FVAR6
	LDA FVAR6
	CMP S_PLAYER
	BNE @LOOP
@DIV
	JSR _F32ARG
	JSR _DIVIDE
	RTS
	
;state_cp_sum() 
;sums all candidates' CP at current CP_ADDR/HS_ADDR
;adds result to V_POPSUM; for single-use, clear first
_STATSUM 
	LDY #00
@LOOP
	JSR _STATSM2
	CLC 
	ADC V_POPSUM+10
	STA V_POPSUM+10
	BCC @NOC
	INC V_POPSUM+11
@NOC
	TYA
	ASL 
	TAX 
	JSR _STATSM2
	CLC 
	ADC V_POPSUM,X
	STA V_POPSUM,X
	BCC @NOC2
	INC V_POPSUM+1,X
@NOC2 
	INY 
	CPY S_PLAYER ;loop per player
	BNE @LOOP
@RTS 
	RTS 
;sum from history check
_STATSM2 
	LDA V_SUMFH
	BEQ @FROMCP
	LDA (HS_ADDR),Y
	RTS 
@FROMCP 
	LDA (CP_ADDR),Y
	RTS 

;popsum_to_args
_POPSUM2ARGS
	LDA V_POPSUM,Y
	STA FARG1
	LDA V_POPSUM+1,Y
	STA FARG2
	LDA V_POPSUM+10
	STA FARG3
	LDA V_POPSUM+11
	STA FARG4
	RTS

;state_control_count(A = party)
;counts the number of states party A is winning
;(only on the map)
;returns to A
;LOCAL: FRET1,FY1
_CTRLCNT 
	TAY 
	STY FY1
	LDX #01
	LDA #00
	STA FRET1
@LOOP 
	LDA V_CTRL,X
	CMP FY1
	BNE @SKIPADD
	INC FRET1
@SKIPADD 
	INX 
	CPX #STATE_C
	BNE @LOOP
	RTS 

;popsum_draw_combo_1() 
_POPCMB1
	LDA V_PARTY
	BNE @SKIP
	JSR _POPSUM ;only ever done at the start of a WEEK
@SKIP
	LDA S_SKIPGAME
	BNE @RTS
	LDA #STATE_C
	STA FARG5
	JSR _DRWPOP
@RTS
	RTS 
	
;popsum_draw_combo_2()
;POPCMB1 for all states
_POPCMB2
	LDA #STATE_C
	STA FARG5
	JSR _POPCMB1
	RTS

;popsum_draw_combo_3()
;POPSUM for all states
_POPCMB3
	LDA #STATE_C
	STA FARG5
	JSR _POPSUM
	RTS

;candidate_display_loop() 
;shows all candidates
_CANDLOOP 
	LDA #$00
	STA V_REDRW1
	STA V_PARTY
	JSR _CANDLOAD
@LOOP 
	JSR _DRWCAND
	JSR _CANDSWAP
	JSR _FTC
	LDA V_PARTY
	BNE @LOOP
	RTS 

;pop_sum_reset() 
;clears V_POPSUM
_POPSUMR 
	LDX #00
	LDA #00
@LOOPCLR STA V_POPSUM,X
	INX 
	CPX #$0C
	BNE @LOOPCLR
	RTS 

;max2nd() 
;max2() but instead gets the second highest value
;only guaranteed a second value, not a second party
;quits if initial tie
_MAX2ND
	JSR _MAX2
	
	BEQ @TIE
	ASL 
	TAY 
	DEY 
	DEY 
	LDA V_MAX,Y
	STA V_MAXHOLD
	LDA V_MAX+1,Y
	STA V_MAXHOLD+1
	TYA
	STA V_MAXHOLD+2
	
	LDA #$00
	STA V_MAX,Y
	STA V_MAX+1,Y
	JSR _MAX2
	
	PHA
	LDY V_MAXHOLD+2
	LDA V_MAXHOLD
	STA V_MAX,Y
	LDA V_MAXHOLD+1
	STA V_MAX+1,Y
	PLA
@TIE
	RTS 

;max2() 
;2B maximum where values are (L)(H) pairs in V_MAX
;returns to MAXLOW/MAXHIGH; if not tie, A = index + 1, otherwise A = 0
_MAX2
	LDA #00
	STA MAXLOW
	STA MAXHIGH
	
	LDX #01
	JSR _MAXA
	LDX #01
	JSR _MAXB
	PHA 
	LDA MAXVAR2
	STA MAXHIGH
	PLA 
	BNE @NOTTIE
	LDX #00
	JSR _MAXA
	LDX #00
	JSR _MAXB
	PHA 
	LDA MAXVAR2
	STA MAXLOW
	PLA 
@NOTTIE
	RTS 
_MAX2B
	JSR _MAX1B
	JSR _MAX2
	RTS

;max_a(x = V_MAX offset)
;puts maximum value in MAXVAR2
_MAXA 
	LDY #$01
	LDA #00
	STA MAXVAR2
	STA MAXVAR3
@LOOP 
	LDA V_MAX,X
	CMP MAXVAR2
	BCC @SKIPSTA
	STA MAXVAR2
@SKIPSTA 
	INX 
	INX 
	INY 
	CPY S_PLAY1M
	BNE @LOOP

	RTS 

;max_b(X = V_MAX offset)
;returns A = index + 1 (0 for tie)
_MAXB
	LDY #01
@RLOOP 
	LDA V_MAX,X
	CMP MAXVAR2
	BNE @SKIP
	LDA MAXVAR3
	BNE @TIE
	STY MAXVAR3
@SKIP 
	INX 
	INX 
	INY 
	CPY S_PLAY1M
	BNE @RLOOP

	LDA MAXVAR3
	RTS 
@TIE 
	LDA #00
	RTS 

;max_c()
;returns to V_MAXPL the indices in V_MAX holding MAXLOW/MAXHIGH
;X/MAXVAR1 = number of tied parties
_MAXC
	LDA #00
	TAX
	TAY
@CLRLOOP
	STA V_MAXPL,X
	INX
	CPX #PLAYERMAX
	BNE @CLRLOOP
	TAX
	STA MAXVAR1 ;index for V_MAXPL
	
@LOOP	
	LDA V_MAX,Y
	CMP MAXLOW
	BNE @SKIP
	LDA V_MAX+1,Y
	CMP MAXHIGH
	BNE @SKIP
	;equal
	TXA
	PHA
	LDX MAXVAR1
	STA V_MAXPL,X
	INC MAXVAR1
	PLA
	TAX
@SKIP
	INY
	INY
	INX
	CPX #PLAYERMAX
	BNE @LOOP
	LDX MAXVAR1
	RTS

;max_reset() 
_MAXR 
	LDA #00
	TAX
@LOOP 
	STA V_MAX,X
	INX 
	CPX #$08
	BNE @LOOP
	RTS 
	
;color_map() 
;maps party control for all states to map color
;does NOT set party control -- use _STCTRL or _FINALCP
_MAPCOL 
	JSR _CPOFFR
@LOOP 
	LDX CPSTATE
	JSR _LDACTRL
	TAY 
	LDA V_PTCOL,Y
	STA V_STCOL,X

	LDA V_COLMSK,X
	BEQ @SKIPMSK ;if mask is nonzero, blank state
	LDY #UND_PRTY
	LDA V_PTCOL,Y
	STA V_STCOL,X
@SKIPMSK 

	JSR _CPOFFI
	BNE @LOOP
	RTS 
	
;skip_game_check()
;if all players are AIs AND quick game is on, activates S_SKIPGAME
_SKIPCHK
	LDA S_QUICKG
	BEQ @RTS
	LDX #00
@LOOP
	LDA V_AI,X
	BEQ @RTS
	INX
	CPX S_PLAYER
	BNE @LOOP
	LDA #$01
	STA S_SKIPGAME
@RTS	
	RTS

;clears poll-by-region counts
_CLRPOLL
	LDX #$00
	TXA
	STX V_POLLCT
@CLR3
	STA V_POLL,X
	STA V_REGISS,X
	INX
	CPX #REGION_C
	BNE @CLR3
	RTS
	
;calculate_float_max(floats in V_CPFLOAT)
;stores winning party index + 1 to V_FLOATMAX
_FLOATMAX
	LDA #00
	STA FVAR1
	LDA #00
	LDY #00
	JSR _162FAC ;FAC = 0
@TIE3 
	LDY FVAR1
	JSR _FLT2OFF ;V_POPULAR should be loaded
	LDA OFFSET
	LDY OFFSET+1
	JSR _FCOMP
	CMP #$FF
	BNE @LESSEQ
	LDA OFFSET
	LDY OFFSET+1
	JSR _MOVFM ;set new maximum to FAC
@LESSEQ
	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER
	BNE @TIE3
	;max popular vote value is in FAC
	LDA #00
	STA FVAR1
	LDA #$FF
	STA FX1 ;party list index (must be set to an index; if it is set twice, quit)
@TIE3L2 
	LDY FVAR1
	JSR _FLT2OFF
	LDA OFFSET
	LDY OFFSET+1
	JSR _FCOMP
	CMP #00
	BNE @NOTMAX
	LDX FX1
	CPX #$FF
	BNE @FALSE ;quit
	LDX FVAR1
	STX FX1
@NOTMAX
	INC FVAR1
	LDA FVAR1
	CMP S_PLAYER
	BNE @TIE3L2
	LDX FX1
	INX
	TXA
	JMP @RTS
@FALSE
	LDA #00
@RTS
	STA V_FLOATMAX
	RTS
	
;calculate_plurality()
;calculates (EC / player count) + 1
_PLURAL
	LDX #00
	STX V_PLURAL
	STX V_PLURAL+1
@SUMLOOP
	LDA V_EC,X
	CLC
	ADC V_PLURAL
	STA V_PLURAL
	BCC @NOCARRY
	INC V_PLURAL+1
@NOCARRY
	INX
	CPX #STATE_C
	BNE @SUMLOOP
	
	LDA V_PLURAL+1
	LDY V_PLURAL
	JSR _162FAC
	JSR _FAC2ARG
	LDA #$00
	LDY S_PLAYER
	JSR _162FAC
	JSR _DIVIDE
	;calculate plurality * 1.5
	JSR _FAC2F3
	JSR _FAC2ARG
	LDX #00
	TXA
@CLRFAC
	STA FAC,X
	INX 
	CPX #FLOATLEN
	BNE @CLRFAC
	LDA #$81
	STA FAC
	LDA #$C0
	STA FAC+1 ;1.5
	JSR _MULTIPLY
	
	LDX #00
@COPY
	LDA FAC,X
	STA V_PLURALF,X
	INX
	CPX #FLOATLEN
	BNE @COPY
	LDA V_PLURALF+1
	AND #%01111111
	STA V_PLURALF+1
	;restore FAC
	JSR _F32FAC
	JSR _FAC232
	LDA FAC+3
	STA V_PLURAL
	LDA FAC+4
	STA V_PLURAL+1
	
	CLC
	INC V_PLURAL+1
	BCC @RTS
	INC V_PLURAL
@RTS
	RTS

;history_week_offset() 
_HSOFFS 
	+__LAB2O V_HIST ;(WEEK - 1) * STATE COUNT * HISTORY BLOCK
	LDX V_WEEK
	DEX
	STX FX1
@ADDLOOP
	LDX FX1
	BEQ @ZERO
	LDX #STATE_C-1
	LDY #HISTBLOCK
	JSR _OFFSET
	LDX V_WEEK
	DEC FX1
	JMP @ADDLOOP
@ZERO
	LDA OFFSET
	STA HS_ADDR
	LDA OFFSET+1
	STA HS_ADDR+1
	RTS
;history_state_offset(X = state index)
;call after above to set state
_HSOFFS2
	LDA HS_ADDR
	STA OFFSET
	LDA HS_ADDR+1
	STA OFFSET+1
	DEX
	LDY #HISTBLOCK
	JSR _OFFSET
	LDA OFFSET
	STA HS_ADDR
	LDA OFFSET+1
	STA HS_ADDR+1
	RTS
;history_address_increment()
;increments to next state
_HSOFFI
	LDA HS_ADDR
	CLC
	ADC #HISTBLOCK
	STA HS_ADDR
	BCC @SC
	INC HS_ADDR+1
@SC
	RTS
;history_address_reset()
;resets history address to WEEK 1's history
_HSOFFR
	LDA #<V_HIST
	STA HS_ADDR
	LDA #>V_HIST
	STA HS_ADDR+1
	RTS
		
;attract_mode()
_ATTRACT
	LDX #00
@LOOP1
	LDA #C_DRED
	STA V_TITLANIM+1,X
	LDA #C_WHITE
	STA V_TITLANIM+2,X
	LDA #C_BLUE
	STA V_TITLANIM+3,X
	INX
	INX
	INX
	CPX #21
	BNE @LOOP1
	
@CYCLE
	LDA #160
	JSR _RNG
	TAX
	LDA #$04
	JSR _RNG
	CLC
	ADC #ALPHAS
	STA V_SCREEN+800,X
	LDA #$0F
	JSR _RNG
	CLC
	ADC #$01
	STA V_COLRAM+800,X
	
	LDX #20
	
	LDA V_TITLANIM+20
	STA FVAR3 ;end
@LOOP
	LDA V_TITLANIM-1,X
	STA V_TITLANIM,X

	DEX
	CPX #00
	BNE @LOOP
	
	LDA FVAR3
	STA V_TITLANIM+0

	JSR _RANDSTATE
@REROLL
	LDA #$0F
	JSR _RNG
	BEQ @REROLL
	LDX FSTATE
	STA V_STCOL,X
	JSR _DRWMAP
	
	LDY #00
	LDX #00
@WAIT
	INX
	BNE @WAIT
	INY
	CPY #$30
	BNE @WAIT
	
	JSR _SCNKEY
	JSR _GETIN
	CMP #$00
	BEQ @CYCLE
	
	LDA #$00
	STA FVAR3
	RTS
	
;final_cp_control() 
;sets final control values, breaks ties
_FINALCP
	LDA #00
	STA V_MOE
	STA V_POLLON
	STA V_SUMFH
	
	JSR _POPCMB3
	JSR _FLOATMAX
	STA V_POPWIN
	
	JSR _CPOFFR
	LDA #$FF
	STA V_MARGIN
@SLOOP 
	JSR _PCTRL
	CMP #UND_PRTY
	BNE @SKIPTIE
	
	JSR _TIE
	PHA
	LDX CPSTATE
	LDA FRET3
	STA V_TIERES,X
	PLA
@SKIPTIE  
	LDX CPSTATE
	STA V_CTRL,X

	JSR _CPOFFI
	BNE @SLOOP
	RTS 

	
;set_negative_flag()
;sets all floating-point negative flags to OFF
_POSFLOAT
	;set sign to positive for both arguments
	LDA #$00
	STA ARG+5
	STA FAC+5
	LDA #%10000000
	ORA FAC+1
	STA FAC+1
	LDA #%01111111
	AND ARG+1
	LDA #%10000000
	ORA ARG+1
	STA ARG+1
	RTS
	
;adds 2^(HQ+1) CP to each state for each party
_HQAPPLY
	LDA V_PARTY
	STA FPARTY
	JSR _CPOFFR
	+__LAB2O V_HQ
@STALOOP
	LDA #00
	STA V_PARTY
	LDY CPSTATE
@PLYLOOP
	LDX V_PARTY
	JSR _LDAHQ
	
	LDX BITRET
	INX
	LDA #01
@2LOOP
	ASL
	DEX
	BNE @2LOOP
	STA FRET1
	JSR _ADDCP
	
	INC V_PARTY
	LDA V_PARTY
	CMP S_PLAYER
	BNE @PLYLOOP
	
	JSR _CPOFFI
	BNE @STALOOP
	
	LDA FPARTY
	STA V_PARTY
	RTS
	
;hq_plus(Y = state index)
;adds an HQ to state index Y for party V_PARTY, to a maximum of 3
;returns A = successful build
_HQPLUS
	LDX V_PARTY
	JSR _LDAHQ
	
	INC BITRET
	LDA BITRET
	CMP #$04
	BEQ @FAIL
	
	LDA BITRET
	STA BITSTA
	LDX V_PARTY
	JSR _STA2BIT
	
	LDA #01
	RTS
@FAIL
	LDA #00
	RTS

;hq_minus(Y = state index)
;removes an HQ to state index Y for party V_PARTY
_HQMINUS
	LDX V_PARTY
	JSR _LDAHQ
	
	DEC BITRET
	LDA BITRET
	BMI @FAIL
	
	LDA BITRET
	STA BITSTA
	LDX V_PARTY
	JSR _STA2BIT
@FAIL
	RTS

;load_HQ(X = party index, Y = state index)
;returns HQ value to BITRET
_LDAHQ
	+__LAB2O V_HQ
	JSR _LDA2BIT
	RTS
	
;HQ_cost()
_HQCOST
	LDA C_MONEY
	SEC
	SBC #HQ_COST
	STA C_MONEY
	RTS

;load_2_bits(X = index (0-3), OFFSET = address, Y = address offset)
;returns to BITRET
_LDA2BIT
	TXA
	ASL
	TAX
	STX FX1
	JSR _LDABIT
	STA BITRET
	LDX FX1
	INX
	JSR _LDABIT
	ASL
	ORA BITRET
	STA BITRET
	RTS
	
;store_2_bits(X = index (0-3), OFFSET = address, Y = address offset, BITSTA = input)
_STA2BIT
	TXA
	ASL
	TAX
	STX FX1
	LDA BITSTA
	AND #%00000001
	JSR _STABIT
	LDX FX1
	INX
	LDA BITSTA
	AND #%00000010
	JSR _STABIT
	RTS
	
;results() 
;goes over regions one at a time
;LOCAL: FVAR4
_RESULTS
	JSR _GX_CLRS
	JSR _FILMASK
	JSR _MAPCOL
	JSR _MAPCMB1

	LDA #$01
	STA C_CREG ;region counter
@REGLOOP 
	JSR _CLRMENR
	LDX C_CREG
	JSR _LREGLIM
	LDY LOWSTATE
	LDA HIGHSTATE
	STA FARG5
	LDA #00
@CLRLOOP 
	STA V_COLMSK,Y ;clear mask
	INY 
	CPY HIGHSTATE
	BNE @CLRLOOP

	JSR _MAPCOL
	JSR _MAPCMB1
	LDA C_CREG
	JSR _DRWREGS
	JSR _DRWWIN
	JSR _POPSUM
	JSR _SUMEC
	JSR _DRWPOP2
	LDX C_CREG
	LDA #00
	STA V_SUMFH
	JSR _DRWPOLL

	INC C_CREG
	LDA C_CREG
	CMP #REGION_C+1
	BNE @REGLOOP

	RTS 
	
_ISSUES 
	+__LAB2A2 V_ISSUE,D_ISSUE
	LDA #00
	STA FVAR3 ;compressed 1
	STA FVAR4 ;..2
	STA FVAR5 ;..3
	STA FARG5

@TOP 
	JSR _ISSUES2

	LDA FARG1
	CLC 
	ADC #$08
	STA FARG1
	BCC @CARRY
	INC FARG2

@CARRY 
	LDA FARG3
	CLC 
	ADC #$03
	STA FARG3
	BCC @CARRY2
	INC FARG4
@CARRY2 
	INC FARG5
	LDA FARG5
	CMP #STATE_C
	BNE @TOP
	RTS 
;3-hex decompress (A=VAL,first bit in arg5)
_ISSUES2 
	LDY #00
@3LOOP 
	LDA (FARG3),Y
	STA FVAR3,Y
	INY 
	CPY #$03
	BNE @3LOOP

	LDY #$08
@8LOOP 
	LDX #$03
	LDA #00
@RLOOP 
	ROR FVAR3
	ROR FVAR3+1
	ROR FVAR3+2
	ROR 
	DEX 
	BNE @RLOOP

	LDX #05
@VALOOP LSR
	DEX 
	BNE @VALOOP

	DEY 
	STA (FARG1),Y
	TYA 
	BNE @8LOOP
	RTS 

;load_control(X = state index)
_LDACTRL
	;COMMENT THE NEXT 2 LINES TO VIEW AI BEHAVIOR
	LDA V_POLLON
	BEQ @CTRL
	LDA V_POLLMAP,X
	RTS
@CTRL
	LDA V_CTRL,X
	RTS

;draw_settings_update()
;toggles setting +/-
_DRWSETG
	+__COORD P_SETTR+2,P_RIGHT-1
	LDA #$01
	STA FVAR1 ;option count
@LOOP
	LDX FVAR1
	LDA V_FLOAT3,X
	JSR _DRWSIGN
	DEC GX_CCOL
	INC GX_CROW
	INC FVAR1
	LDA FVAR1
	CMP #SETTINGC
	BNE @LOOP
	RTS
	
;3p_party_select()
_3PPARTY
	LDA S_PLAYER
	CMP #$03
	BNE @RTS
@FTC
	JSR _CLRBR

	+__COORD P_CONVNR,P_CONVNC
	+__LAB2XY T_3PARTY
	JSR _GX_STR
	
	+__COORD P_NOYESR,P_NOYESC-1
	LDX #$05
	JSR _3PPARTY2
	+__COORD P_NOYESR+1,P_NOYESC-1
	LDX #$06
	JSR _3PPARTY2
	
	LDX #P_NOYESR
	LDY #P_NOYESR+1
	JSR _RSELECT
	STA S_3PMODE
	JSR _FTC
	BNE @FTC
@RTS
	RTS
;X = party name index
_3PPARTY2
	LDA D_PTCOL2,X
	STA GX_DCOL
	+__LAB2O D_PARTY
	LDY #11
	JSR _OFFSET
	+__O2XY
	JSR _GX_STR
	RTS
	
;init_ec() 
;copies EC values
_INITEC 
	LDA #<D_EC
	STA FARG1
	LDA #>D_EC
	STA FARG2
	LDA #<V_EC
	STA FARG3
	LDA #>V_EC
	STA FARG4
	LDA #STATE_C
	STA FARG5
	JSR _COPY
	RTS 
	
;partisan_float_calculation()
;calculates and stores (1 / ((player count - 2) * S_PARTISAN))
_PRTFCALC
	LDA #00
	LDY #01
	JSR _162FAC
	JSR _FAC2ARG
	
	LDA #00
	STA OFFSET
	STA OFFSET+1
	LDA S_PLAYER
	SEC
	SBC #01
	TAX
	LDY S_PARTISAN
	INY
	JSR _OFFSET
	
	LDA #00
	LDY OFFSET
	JSR _162FAC
	JSR _DIVIDE
	LDX #<V_INCPERC
	LDY #>V_INCPERC
	JSR _MOVMF
	LDA V_INCPERC+1
	AND #%01111111
	STA V_INCPERC+1
	RTS

;checks if every player is an AI	
_ALLAICHK
	LDX #00
@LOOP
	LDA V_AI,X
	BEQ @FALSE
	INX
	CPX S_PLAYER
	BNE @LOOP
	LDA #01
@FALSE
	STA V_ALLAI
	RTS

;counts number of swing states (SL difference = 0)
_SWINGCT
	LDA #00
	STA V_SWINGCT
	JSR _CPOFFR
@LOOP
	LDY #CPBLEAN
	LDA (CP_ADDR),Y
	INY
	STA FVAR1
@EQLOOP
	LDA (CP_ADDR),Y
	BEQ @TRUE
	CMP FVAR1
	BNE @FALSE
	INY
	CPY #CPBLOCK
	BNE @EQLOOP
@TRUE
	LDA #01
	BNE @ADD
@FALSE
	LDA #00
@ADD
	CLC
	ADC V_SWINGCT
	STA V_SWINGCT
	
	JSR _CPOFFI
	BNE @LOOP
	
	LDA V_SWINGCT
	LSR
	LSR
	LSR
	LSR
	CLC
	ADC #01
	CMP #ACTIONMAX+1
	BCC @SKIP
	LDA #ACTIONMAX
@SKIP
	STA V_TVMAX
	RTS
	
;domination_check()
;if a state's winner has controlled it (had a margin > 0) for the entire game, +1 SL
;if a candidate has won in a V_LANDSLIDE, +SL to all states they won
_DOMCHECK
	JSR _SUMEC
	JSR _CPOFFR
	LDA #01
	STA V_SUMFH
@STATELOOP
	LDA #01
	STA V_WEEK
	LDX CPSTATE
	JSR _LDACTRL
	STA FVAR4 ;state winner
@WEEKLOOP
	JSR _HSOFFS
	LDX CPSTATE
	JSR _HSOFFS2
	
	LDA #01
	STA V_MARGIN
	JSR _PCTRL
	LDA FRET3 ;get margin winner, not CTRL value from history
	CMP FVAR4 ;winner index
	BNE @FALSE

	INC V_WEEK
	LDA V_WEEK
	CMP #WEEKMAX+1
	BNE @WEEKLOOP
@TRUE
	LDA FVAR4
	CLC
	ADC #CPBLEAN
	TAY
	LDA (CP_ADDR),Y
	CLC
	ADC #01
	STA (CP_ADDR),Y
	
@FALSE
	LDX V_LANDSLIDE
	BEQ @LANDSLIDE
	DEX
	STX FX1
	LDX CPSTATE
	LDA V_CTRL,X ;get state's winner
	CMP FX1
	BNE @LANDSLIDE
	
	LDA FX1
	CLC
	ADC #CPBLEAN
	TAY
	LDA (CP_ADDR),Y
	CLC
	ADC #02
	STA (CP_ADDR),Y
@LANDSLIDE

	JSR _CPOFFI
	BNE @STATELOOP
	RTS

